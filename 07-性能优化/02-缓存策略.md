# 缓存策略详解

## 1. 强缓存 (Strong Cache)

**浏览器发现有强缓存，直接从本地取，不向服务器发请求 (Status 200 from disk cache)。**

### Cache-Control (HTTP/1.1) **推荐**
- `max-age=3600`：3600秒内有效。
- `no-cache`：不走强缓存，走协商缓存。
- `no-store`：完全不缓存。
- `public / private`：是否允许中间代理（CDN）缓存。

### Expires (HTTP/1.0)
使用绝对时间（`Expires: Wed, 21 Oct 2021 07:28:00 GMT`）。
**缺点**：如果客户端和服务端时间不一致，会导致缓存失效。

---

## 2. 协商缓存 (Negotiation Cache)

**浏览器问服务器："这个文件过期没？"**
- 没过期 -> 服务器回 **304 Not Modified** (空 body)，浏览器读本地。
- 过期了 -> 服务器回 **200 OK** (新文件)，浏览器存新文件。

### ETag / If-None-Match (优先级高)
- **ETag**：文件的唯一指纹（Hash 值）。
- 流程：
  1. 第一次请求，服务器回 `ETag: "abc"`.
  2. 第二次请求，浏览器带 `If-None-Match: "abc"`.
  3. 服务器对比 hash，一样回 304，不一样回 200 + 新 ETag。
- **优点**：精准（文件内容变了 ETag 才会变）。

### Last-Modified / If-Modified-Since (优先级低)
- **Last-Modified**：文件最后修改时间。
- **缺点**：最小单位是秒（1秒内改多次无法感知）；只要文件编辑过（时间变了）即使内容没变也会重新下载。

---

## 3. 最佳实践策略

### HTML 文件：协商缓存
**HTML 不能设强缓存！**
因为 HTML 是入口，如果它被强缓存了，用户永远拿不到新的 JS/CSS 链接。
建议：`Cache-Control: no-cache` (每次都问服务器)。

### JS / CSS / 图片：强缓存 + Hash
给文件名带 UUID Hash (`app.a1b2c3.js`)。
设置超长缓存：`Cache-Control: max-age=31536000` (1年)。

**更新机制**：
1. 开发者发布新版，构建出新的 `app.d4e5f6.js`。
2. HTML 中引用的文件名变了。
3. 浏览器下载新的 HTML (协商缓存)。
4. 解析发现新的 JS 文件名，本地没有，请求下载新的。
5. 旧的 JS 文件虽然还在缓存里，但没人引用它，自然就废弃了。
