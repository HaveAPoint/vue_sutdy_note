# 首屏渲染优化有哪些方法

## 1. 资源加载优化 (减小包体积)

### 路由懒加载 (最重要)
不要把所有页面打包进一个 js 文件。访问哪个页面，才加载哪个页面的代码。

```javascript
// router.js
const Home = () => import('./Home.vue') // 异步组件
```

### Tree Shaking
去除无用代码。即使引入了整个库（如 lodash），构建工具也只打包你用到的函数。

### Gzip / Brotli 压缩
服务端 Nginx 开启 Gzip，能压缩 70% 左右的体积。

### 图片优化
- 使用 WebP 格式。
- 图片懒加载 (`v-lazy`, `<img loading="lazy">`)。
- 小图标使用 SVG 或 Base64。

---

## 2. 网络传输优化

### CDN 分发
把静态资源（JS/CSS/Img）放到 CDN，用户就近下载，速度极快。

### HTTP/2
多路复用，通过一个 TCP 连接并行传输多个文件，解决队头阻塞。

### 预加载 (Preload / Prefetch)
- `<link rel="preload">`：高优先级加载当前页需要的资源。
- `<link rel="prefetch">`：空闲时加载下一页可能用到的资源。

---

## 3. 渲染过程优化

### SSR (服务端渲染)
**核心解决首屏白屏问题**。
服务器直接生成 HTML 字符串返回给浏览器，浏览器接到即可显示内容，无需等待 JS 下载执行。
- 框架：Nuxt.js (Vue), Next.js (React)。

### 骨架屏 (Skeleton)
在数据回来之前，先展示页面的大致轮廓（灰色方块），提升感官体验。

### 避免阻塞
- CSS 放在 `<head>`。
- JS 放在 `<body>` 底部或使用 `defer`。

---

## 4. 场景题：新用户 vs 老用户 针对性优化

### 对于新用户 (无缓存)
**目标：让首屏尽可能小。**
- **关键资源内联**：把首屏必要的 CSS 直接写在 HTML 的 `<style>` 里，避免多一次 CSS 请求。
- **SSR**：服务端直接给结果。
- **分包策略**：确保 vendor (第三方库) 和 app code 分离，虽然新用户都要下，但为转化成老用户做铺垫。

### 对于老用户 (有缓存)
**目标：最大化利用 HTTP 缓存。**
- **强缓存策略**：配置 Nginx，让静态资源（带 hash 的文件名）缓存时间设为 1 年 (`Cache-Control: max-age=31536000`)。
- **按需更新**：webpack 的 `contenthash` 确保只改了 A 文件，只有 A 的 hash 变，其他文件的缓存依然有效。
- **Service Worker**：使用 PWA 技术，将 App Shell 离线缓存，实现"秒开"。
