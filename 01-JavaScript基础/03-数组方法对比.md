# 数组方法对比：find/filter 与 map/forEach

## find vs filter

### 核心区别

| 方法 | 返回值 | 何时停止 | 用途 |
|------|--------|----------|------|
| `find` | **单个元素** 或 `undefined` | 找到第一个匹配就停止 | 找一个 |
| `filter` | **新数组** | 遍历全部 | 找多个 |

### find - 找第一个

```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
]

// 找到第一个匹配的元素
const user = users.find(u => u.id === 2)
console.log(user)  // { id: 2, name: 'Bob' }

// 找不到返回 undefined
const notFound = users.find(u => u.id === 999)
console.log(notFound)  // undefined
```

### filter - 找所有

```javascript
const numbers = [1, 2, 3, 4, 5, 6]

// 找出所有偶数
const evens = numbers.filter(n => n % 2 === 0)
console.log(evens)  // [2, 4, 6]

// 没有匹配返回空数组
const greaterThan10 = numbers.filter(n => n > 10)
console.log(greaterThan10)  // []
```

### 性能对比

```javascript
const largeArray = Array.from({ length: 100000 }, (_, i) => i)

// find 更快（找到即停止）
console.time('find')
largeArray.find(n => n === 50)
console.timeEnd('find')  // 约 0.01ms

// filter 较慢（需遍历全部）
console.time('filter')
largeArray.filter(n => n === 50)
console.timeEnd('filter')  // 约 1ms
```

### 使用场景

```javascript
// find：根据 ID 获取用户
const currentUser = users.find(u => u.id === currentUserId)

// filter：获取所有管理员
const admins = users.filter(u => u.role === 'admin')
```

---

## map vs forEach

### 核心区别

| 方法 | 返回值 | 是否改变原数组 | 用途 |
|------|--------|----------------|------|
| `map` | **新数组** | 否 | 转换数据 |
| `forEach` | `undefined` | 否 | 执行副作用 |

### map - 数据转换

```javascript
const numbers = [1, 2, 3, 4, 5]

// 每个元素乘以 2，返回新数组
const doubled = numbers.map(n => n * 2)
console.log(doubled)   // [2, 4, 6, 8, 10]
console.log(numbers)   // [1, 2, 3, 4, 5] 原数组不变
```

```javascript
const users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
]

// 提取属性
const names = users.map(u => u.name)
console.log(names)  // ['Alice', 'Bob']

// 转换结构
const formatted = users.map(u => ({
  ...u,
  displayName: `${u.name} (${u.age}岁)`
}))
```

### forEach - 执行副作用

```javascript
const numbers = [1, 2, 3]

// 没有返回值
const result = numbers.forEach(n => {
  console.log(n)  // 1, 2, 3
})
console.log(result)  // undefined
```

```javascript
// 副作用操作示例
const users = [{ name: 'Alice' }, { name: 'Bob' }]

users.forEach(user => {
  // 调用 API
  saveToDatabase(user)
  // 打印日志
  console.log(`Saved ${user.name}`)
})
```

### 常见错误

```javascript
// 错误：用 forEach 期望返回值
const doubled = numbers.forEach(n => n * 2)
console.log(doubled)  // undefined！

// 正确：用 map
const doubled = numbers.map(n => n * 2)
```

```javascript
// 错误：用 map 但不使用返回值
numbers.map(n => {
  console.log(n)  // 浪费性能，应该用 forEach
})
```

### 链式调用

```javascript
const numbers = [1, 2, 3, 4, 5]

// map 可以链式调用
const result = numbers
  .filter(n => n > 2)      // [3, 4, 5]
  .map(n => n * 2)         // [6, 8, 10]
  .reduce((a, b) => a + b) // 24

// forEach 不能链式（返回 undefined）
numbers.forEach(n => n * 2).filter(...)  // 报错！
```

---

## 其他相关方法

### findIndex - 找索引

```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' }
]

const index = users.findIndex(u => u.id === 2)
console.log(index)  // 1
```

### some - 存在判断

```javascript
const numbers = [1, 2, 3, 4, 5]

// 是否存在大于 3 的数
const hasLarge = numbers.some(n => n > 3)
console.log(hasLarge)  // true
```

### every - 全部判断

```javascript
const numbers = [2, 4, 6, 8]

// 是否全部为偶数
const allEven = numbers.every(n => n % 2 === 0)
console.log(allEven)  // true
```

### reduce - 聚合

```javascript
const numbers = [1, 2, 3, 4, 5]

// 求和
const sum = numbers.reduce((acc, n) => acc + n, 0)
console.log(sum)  // 15
```

---

## 总结

| 方法 | 返回 | 停止条件 | 典型场景 |
|------|------|----------|----------|
| `find` | 元素/undefined | 找到即停 | 根据条件找一个 |
| `filter` | 新数组 | 遍历全部 | 根据条件找多个 |
| `map` | 新数组 | 遍历全部 | 数据转换 |
| `forEach` | undefined | 遍历全部 | 执行副作用 |
| `findIndex` | 索引/-1 | 找到即停 | 找索引 |
| `some` | boolean | 找到即停 | 存在判断 |
| `every` | boolean | 不满足即停 | 全部判断 |
| `reduce` | 任意值 | 遍历全部 | 聚合计算 |

## 面试要点

1. **find 返回元素，filter 返回数组**
2. **map 返回数组，forEach 返回 undefined**
3. find/some/every 会提前终止，性能更好
4. map 用于转换，forEach 用于副作用
5. 优先用函数式方法，避免手动 for 循环
