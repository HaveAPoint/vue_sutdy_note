# 变量提升与暂时性死区

## 变量提升 (Hoisting)

JavaScript 引擎在执行代码前，会先扫描代码，将变量声明和函数声明"提升"到作用域顶部。

### var 的提升

```javascript
console.log(a) // undefined（不是报错！）
var a = 1
console.log(a) // 1

// 实际上被解析成：
var a          // 声明被提升
console.log(a) // undefined
a = 1          // 赋值留在原地
console.log(a) // 1
```

### 函数声明的提升

函数声明会**整体提升**（包括函数体）：

```javascript
sayHello() // 'Hello!' —— 可以在声明前调用

function sayHello() {
  console.log('Hello!')
}
```

### 函数表达式不会整体提升

```javascript
sayHi() // TypeError: sayHi is not a function

var sayHi = function() {
  console.log('Hi!')
}

// 实际解析成：
var sayHi          // 只有变量声明被提升
sayHi()            // 此时 sayHi 是 undefined
sayHi = function() { ... }
```

### 同名的函数和变量

```javascript
console.log(foo) // [Function: foo]

var foo = 1

function foo() {
  console.log('foo')
}

console.log(foo) // 1
```

**规则**：函数声明优先级高于变量声明，但变量赋值会覆盖函数。

## 暂时性死区 (TDZ)

ES6 引入的 `let` 和 `const` 存在**暂时性死区**：从块作用域开始到变量声明之前，访问该变量会报错。

### let 和 const 也会提升，但不会初始化

```javascript
console.log(a) // ReferenceError: Cannot access 'a' before initialization
let a = 1

// 对比 var
console.log(b) // undefined
var b = 1
```

### TDZ 的本质

```javascript
{
  // TDZ 开始
  console.log(x) // ReferenceError
  // ...
  // TDZ 中的任何访问都会报错
  // ...
  let x = 1      // TDZ 结束
  console.log(x) // 1
}
```

### 典型陷阱

```javascript
let x = 1
{
  console.log(x) // ReferenceError（不是 1！）
  let x = 2
}
```

**原因**：内层 `let x` 的声明使得整个块都是 `x` 的 TDZ，外层的 `x` 被"遮蔽"了。

## 经典面试题

### 题目 1：输出什么？

```javascript
var a = 1
function foo() {
  console.log(a)
  var a = 2
}
foo()

// 输出：undefined
// 原因：函数内部的 var a 被提升，遮蔽了外部的 a
```

### 题目 2：输出什么？

```javascript
console.log(typeof a) // 'undefined'
console.log(typeof b) // ReferenceError

var a = 1
let b = 2
```

**注意**：`typeof` 对未声明的变量返回 `'undefined'`，但对 TDZ 中的变量会报错。

### 题目 3：循环中的提升

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// 输出：3 3 3

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100)
}
// 输出：0 1 2
```

**原因**：
- `var` 没有块级作用域，整个循环共享同一个 `i`
- `let` 有块级作用域，每次循环都会创建新的 `j`

### 题目 4：函数提升优先级

```javascript
var foo = function() { console.log(1) }
function foo() { console.log(2) }
foo()

// 输出：1
// 解析顺序：
// 1. 函数声明提升：function foo() { console.log(2) }
// 2. 变量声明提升（var foo）：由于 foo 已存在，忽略
// 3. 变量赋值：foo = function() { console.log(1) }
// 4. 调用 foo()
```

## const 的特殊性

```javascript
const a = 1
a = 2 // TypeError: Assignment to constant variable

const obj = { x: 1 }
obj.x = 2    // OK！对象属性可以修改
obj = {}     // TypeError：不能重新赋值

// 要冻结对象：
const frozen = Object.freeze({ x: 1 })
frozen.x = 2 // 静默失败（严格模式下报错）
```

## 最佳实践

1. **永远使用 `const`**，除非需要重新赋值
2. **需要重新赋值时用 `let`**
3. **永远不要用 `var`**
4. **变量声明放在作用域顶部**，避免 TDZ 困惑

## 总结对比

| 特性 | var | let | const |
|------|-----|-----|-------|
| 作用域 | 函数作用域 | 块级作用域 | 块级作用域 |
| 提升 | 声明提升，初始化为 undefined | 声明提升，但存在 TDZ | 声明提升，但存在 TDZ |
| 重复声明 | 允许 | 不允许 | 不允许 |
| 重新赋值 | 允许 | 允许 | 不允许 |
| 全局声明时 | 挂载到 window | 不挂载 | 不挂载 |

## 面试要点

1. **var 会提升并初始化为 undefined**
2. **let/const 会提升但存在 TDZ**
3. **函数声明整体提升，函数表达式只提升变量**
4. **函数声明优先级高于变量声明**
5. **const 声明的对象，属性可以修改**

## 深入阅读

- [MDN - 变量提升](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)
- [MDN - let 的暂时性死区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)
