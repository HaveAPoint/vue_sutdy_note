# 原型链与继承

## 本质

JavaScript 是基于**原型 (Prototype)** 的语言，不是传统的基于类的语言。即使 ES6 引入了 `class`，底层仍然是原型机制。

## 核心概念

### 1. prototype（显式原型）

每个**函数**都有一个 `prototype` 属性，指向一个对象（原型对象）。

```javascript
function Person(name) {
  this.name = name
}

// Person.prototype 是一个对象
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`)
}

const p1 = new Person('Tom')
const p2 = new Person('Jerry')

p1.sayHello() // Hello, I'm Tom
p2.sayHello() // Hello, I'm Jerry

// p1 和 p2 共享 sayHello 方法，节省内存
console.log(p1.sayHello === p2.sayHello) // true
```

### 2. __proto__（隐式原型）

每个**对象**都有一个 `__proto__` 属性，指向创建它的构造函数的 `prototype`。

```javascript
const p = new Person('Tom')

// 实例的 __proto__ 指向构造函数的 prototype
console.log(p.__proto__ === Person.prototype) // true

// 构造函数的 prototype 也是对象，它的 __proto__ 指向 Object.prototype
console.log(Person.prototype.__proto__ === Object.prototype) // true

// Object.prototype 的 __proto__ 是 null（原型链顶端）
console.log(Object.prototype.__proto__) // null
```

### 3. constructor

原型对象上有一个 `constructor` 属性，指回构造函数本身。

```javascript
console.log(Person.prototype.constructor === Person) // true
console.log(p.constructor === Person) // true
```

## 原型链图解

```
实例 p
  │
  └── p.__proto__  ──────────────────────┐
                                          ▼
                              Person.prototype
                                    │
                                    └── Person.prototype.__proto__ ──┐
                                                                      ▼
                                                          Object.prototype
                                                                │
                                                                └── Object.prototype.__proto__
                                                                              ▼
                                                                            null
```

## 属性查找机制

当访问对象的属性时，JavaScript 会沿着原型链向上查找：

```javascript
function Animal(name) {
  this.name = name
}
Animal.prototype.eat = function() {
  console.log('eating')
}

function Dog(name, breed) {
  Animal.call(this, name)
  this.breed = breed
}
Dog.prototype = Object.create(Animal.prototype)
Dog.prototype.constructor = Dog
Dog.prototype.bark = function() {
  console.log('woof!')
}

const dog = new Dog('Buddy', 'Golden')

// 查找顺序：
dog.name      // 1. dog 自身属性 ✓
dog.breed     // 1. dog 自身属性 ✓
dog.bark()    // 1. dog 自身 ✗ → 2. Dog.prototype ✓
dog.eat()     // 1. dog 自身 ✗ → 2. Dog.prototype ✗ → 3. Animal.prototype ✓
dog.toString()// 1→2→3 都没有 → 4. Object.prototype ✓
```

## 继承的实现方式

### 1. 原型链继承

```javascript
function Parent() {
  this.name = 'parent'
  this.colors = ['red', 'blue']
}
Parent.prototype.sayName = function() {
  console.log(this.name)
}

function Child() {}
Child.prototype = new Parent()

const c1 = new Child()
const c2 = new Child()

c1.colors.push('green')
console.log(c2.colors) // ['red', 'blue', 'green'] 被污染了！
```

**缺点**：
- 引用类型属性被所有实例共享
- 无法向父类传参

### 2. 构造函数继承

```javascript
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue']
}

function Child(name) {
  Parent.call(this, name) // 借用构造函数
}

const c1 = new Child('c1')
const c2 = new Child('c2')

c1.colors.push('green')
console.log(c2.colors) // ['red', 'blue'] 互不影响
```

**缺点**：
- 方法都在构造函数中定义，无法复用
- 无法继承父类原型上的方法

### 3. 组合继承（最常用）

```javascript
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue']
}
Parent.prototype.sayName = function() {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)  // 第二次调用 Parent
  this.age = age
}
Child.prototype = new Parent()  // 第一次调用 Parent
Child.prototype.constructor = Child

const c = new Child('Tom', 18)
c.sayName() // Tom
```

**缺点**：
- 父类构造函数被调用两次

### 4. 寄生组合继承（最佳方案）

```javascript
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue']
}
Parent.prototype.sayName = function() {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

// 核心：使用 Object.create 避免调用父类构造函数
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

const c = new Child('Tom', 18)
```

### 5. ES6 Class 继承（语法糖）

```javascript
class Parent {
  constructor(name) {
    this.name = name
  }
  sayName() {
    console.log(this.name)
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name) // 必须先调用 super
    this.age = age
  }
  sayAge() {
    console.log(this.age)
  }
}

const c = new Child('Tom', 18)
c.sayName() // Tom
c.sayAge()  // 18
```

**注意**：`class` 本质上是语法糖，底层仍然是原型链。

## 面试经典题

### 题目 1：画出原型链

```javascript
function Foo() {}
const f = new Foo()
```

```
f.__proto__ === Foo.prototype
Foo.prototype.__proto__ === Object.prototype
Object.prototype.__proto__ === null

Foo.__proto__ === Function.prototype
Function.prototype.__proto__ === Object.prototype
```

### 题目 2：instanceof 原理

```javascript
// 手写 instanceof
function myInstanceof(obj, constructor) {
  let proto = Object.getPrototypeOf(obj)
  const prototype = constructor.prototype

  while (proto) {
    if (proto === prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```

### 题目 3：new 操作符做了什么？

```javascript
// 手写 new
function myNew(Constructor, ...args) {
  // 1. 创建一个新对象，原型指向构造函数的 prototype
  const obj = Object.create(Constructor.prototype)
  // 2. 执行构造函数，绑定 this
  const result = Constructor.apply(obj, args)
  // 3. 如果构造函数返回对象，则返回该对象；否则返回新创建的对象
  return result instanceof Object ? result : obj
}
```

## 总结

| 概念 | 说明 |
|------|------|
| `prototype` | 函数的属性，指向原型对象 |
| `__proto__` | 对象的属性，指向其构造函数的 prototype |
| `constructor` | 原型对象的属性，指回构造函数 |
| 原型链 | 通过 `__proto__` 形成的链式查找机制 |
| 继承 | 子类通过原型链访问父类的属性和方法 |

## 面试要点

1. **原型链的终点是 `null`**
2. **`__proto__` 是非标准属性**，推荐使用 `Object.getPrototypeOf()`
3. **ES6 class 是语法糖**，底层仍是原型
4. **寄生组合继承是最佳方案**，也是 ES6 class 的实现原理
5. **属性查找沿原型链向上**，找到即停，找不到返回 undefined

## 深入阅读

- [MDN - 继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [You Don't Know JS - this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS)
