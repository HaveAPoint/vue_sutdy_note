# 防抖与节流

## 核心概念

| 概念 | 原理 | 比喻 | 适用场景 |
|------|------|------|----------|
| **防抖 (Debounce)** | 动作停止后延迟执行 | 回城读条：被打断就重新读条 | 搜索框输入、窗口调整大小 |
| **节流 (Throttle)** | 动作执行后冷却一段时间 | 技能CD：CD 没好不能放 | 滚动事件、按钮连点 |

---

## 防抖 (Debounce)

**定义**：连续触发事件，只执行最后一次。

### 1. 基础实现

```javascript
function debounce(fn, delay) {
  let timer = null
  
  return function(...args) {
    // 如果有定时器，清除它（打断回城）
    if (timer) clearTimeout(timer)
    
    // 设置新定时器（重新读条）
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}
```

### 2. 使用示例

```javascript
const handleInput = debounce((e) => {
  console.log('Searching:', e.target.value)
}, 500)

// 用户输入: 'h' -> 'he' -> 'hel' -> Stop
// 只有最后一次 'hel' 会触发 console.log
```

### 3. 可立即执行版

有时候希望第一次触发立即执行，后续触发防抖。

```javascript
function debounceImmediate(fn, delay, immediate = false) {
  let timer = null
  
  return function(...args) {
    if (timer) clearTimeout(timer)
    
    if (immediate && !timer) {
      fn.apply(this, args)
    }
    
    timer = setTimeout(() => {
      if (!immediate) fn.apply(this, args)
      timer = null
    }, delay)
  }
}
```

---

## 节流 (Throttle)

**定义**：连续触发事件，每隔一段时间执行一次。

### 1. 时间戳版（首节流）

第一次立即执行，最后一次可能不执行。

```javascript
function throttleTimestamp(fn, delay) {
  let lastTime = 0
  
  return function(...args) {
    const now = Date.now()
    
    // 如果距离上次执行超过了冷却时间
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}
```

### 2. 定时器版（尾节流）

第一次延迟执行，最后一次会执行。

```javascript
function throttleTimer(fn, delay) {
  let timer = null
  
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}
```

### 3. 完美结合版

第一次立即执行，最后一次也能执行。

```javascript
function throttle(fn, delay) {
  let lastTime = 0
  let timer = null
  
  return function(...args) {
    const now = Date.now()
    const remaining = delay - (now - lastTime)
    
    // 如果冷却时间到了，立即执行
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      fn.apply(this, args)
      lastTime = now
    } else if (!timer) {
      // 否则，设置定时器在剩余时间后执行
      timer = setTimeout(() => {
        fn.apply(this, args)
        lastTime = Date.now()
        timer = null
      }, remaining)
    }
  }
}
```

### 4. 使用示例

```javascript
const handleScroll = throttle(() => {
  console.log('Scrolled!')
}, 1000)

window.addEventListener('scroll', handleScroll)
// 无论滚多快，每秒最多触发一次
```

---

## 总结与区别

| 特性 | 防抖 (Debounce) | 节流 (Throttle) |
|------|-----------------|-----------------|
| **执行次数** | 1 次 (连续操作结束后) | 多次 (按时间间隔规律执行) |
| **关注点** | 结果 (最终状态) | 过程 (中间状态) |
| **典型场景** | 输入框搜索<br>窗口 Resize<br>表单验证 | 滚动加载更多<br>拖拽事件<br>抢购按钮点击 |

## 面试手写题提示

1. **核心**：闭包保存 `timer` 变量。
2. **this 指向**：使用 `apply(this, args)` 确保上下文正确。
3. **参数传递**：使用 `...args` 透传参数。
4. **清理**：防抖要 `clearTimeout`，节流要判断 `!timer` 或时间差。

## 深入阅读

- [Lodash debounce](https://lodash.com/docs/4.17.15#debounce)
- [Lodash throttle](https://lodash.com/docs/4.17.15#throttle)
