# 事件循环 (Event Loop)

## 为什么需要事件循环？

JavaScript 是**单线程**语言，同一时间只能做一件事。但浏览器需要处理：
- 用户交互（点击、滚动）
- 网络请求
- 定时器
- 动画渲染

如果都同步执行，页面会卡死。**事件循环**就是 JS 处理异步操作的机制。

## 核心概念

### 执行栈 (Call Stack)

同步代码的执行场所，**后进先出 (LIFO)**。

```javascript
function a() {
  console.log('a')
  b()
}
function b() {
  console.log('b')
}
a()

// 执行栈变化：
// 1. a() 入栈
// 2. console.log('a') 入栈 -> 执行 -> 出栈
// 3. b() 入栈
// 4. console.log('b') 入栈 -> 执行 -> 出栈
// 5. b() 出栈
// 6. a() 出栈
```

### 任务队列 (Task Queue)

异步任务完成后，回调函数会被放入任务队列，等待执行栈空闲时执行。

任务队列分为两种：
- **宏任务队列 (Macro Task Queue)**
- **微任务队列 (Micro Task Queue)**

## 宏任务 vs 微任务

### 宏任务 (Macro Task)

| 来源 | 示例 |
|------|------|
| script 整体代码 | 第一个宏任务 |
| setTimeout / setInterval | 定时器 |
| setImmediate | Node.js 环境 |
| I/O | 网络请求回调 |
| UI 渲染 | 浏览器环境 |
| requestAnimationFrame | 浏览器环境 |

### 微任务 (Micro Task)

| 来源 | 示例 |
|------|------|
| Promise.then/catch/finally | Promise 回调 |
| async/await | 本质是 Promise |
| MutationObserver | DOM 变化监听 |
| process.nextTick | Node.js 环境（优先级最高） |
| queueMicrotask | 手动添加微任务 |

## 事件循环流程

```
┌─────────────────────────────────────────────────────┐
│                      Event Loop                      │
│                                                      │
│   1. 执行一个宏任务（如 script 整体代码）              │
│              ↓                                       │
│   2. 执行栈清空后，检查微任务队列                      │
│              ↓                                       │
│   3. 执行所有微任务（清空微任务队列）                  │
│              ↓                                       │
│   4. 浏览器可能进行渲染（如果需要）                    │
│              ↓                                       │
│   5. 取下一个宏任务，回到步骤 1                       │
│                                                      │
└─────────────────────────────────────────────────────┘
```

**关键点**：
- 每执行完一个宏任务，就会清空所有微任务
- 微任务优先级高于宏任务
- 微任务执行过程中产生的新微任务，也会在本轮执行

## 经典面试题

### 题目 1：基础输出题

```javascript
console.log('1')

setTimeout(() => {
  console.log('2')
}, 0)

Promise.resolve().then(() => {
  console.log('3')
})

console.log('4')

// 输出：1 4 3 2
```

**分析**：
1. `console.log('1')` - 同步，立即执行
2. `setTimeout` - 宏任务，放入宏任务队列
3. `Promise.then` - 微任务，放入微任务队列
4. `console.log('4')` - 同步，立即执行
5. 执行栈清空，执行微任务 `console.log('3')`
6. 微任务清空，执行下一个宏任务 `console.log('2')`

### 题目 2：嵌套任务

```javascript
console.log('start')

setTimeout(() => {
  console.log('setTimeout')
}, 0)

Promise.resolve()
  .then(() => {
    console.log('promise1')
  })
  .then(() => {
    console.log('promise2')
  })

console.log('end')

// 输出：start end promise1 promise2 setTimeout
```

### 题目 3：async/await

```javascript
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}

async function async2() {
  console.log('async2')
}

console.log('script start')

setTimeout(() => {
  console.log('setTimeout')
}, 0)

async1()

new Promise((resolve) => {
  console.log('promise1')
  resolve()
}).then(() => {
  console.log('promise2')
})

console.log('script end')

// 输出：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

**分析**：
- `await` 后面的代码相当于 `.then()` 里的回调，是微任务
- `await async2()` 会先执行 `async2()`（同步），然后 `await` 之后的代码变成微任务

### 题目 4：综合题

```javascript
console.log('1')

setTimeout(() => {
  console.log('2')
  Promise.resolve().then(() => {
    console.log('3')
  })
}, 0)

new Promise((resolve) => {
  console.log('4')
  resolve()
}).then(() => {
  console.log('5')
  setTimeout(() => {
    console.log('6')
  }, 0)
})

console.log('7')

// 输出：1 4 7 5 2 3 6
```

**分析**：
1. 同步：1 → 4 → 7
2. 微任务：5（同时注册宏任务 6）
3. 宏任务：2（执行后产生微任务 3）
4. 微任务：3
5. 宏任务：6

## Node.js 中的事件循环

Node.js 的事件循环与浏览器有差异，分为 6 个阶段：

```
   ┌───────────────────────────┐
┌─>│           timers          │  setTimeout/setInterval
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │  I/O 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │  系统内部使用
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           poll            │  I/O 轮询
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │  setImmediate
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │  socket.on('close')
   └───────────────────────────┘
```

**Node.js 特有的**：
- `process.nextTick()` - 优先级最高的微任务，在每个阶段切换前执行
- `setImmediate()` - 在 check 阶段执行

## 总结

| 类型 | 常见 API | 执行时机 |
|------|----------|----------|
| 同步代码 | 普通代码 | 立即执行 |
| 微任务 | Promise.then, async/await, queueMicrotask | 当前宏任务结束后 |
| 宏任务 | setTimeout, setInterval, I/O | 下一轮事件循环 |

## 面试要点

1. **JS 是单线程的**，但浏览器是多线程的（渲染线程、网络线程等）
2. **微任务优先级高于宏任务**
3. **每执行完一个宏任务，就会清空所有微任务**
4. **async/await 本质是 Promise**，await 后的代码是微任务
5. **Promise 构造函数中的代码是同步执行的**

## 深入阅读

- [MDN - 事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
- [Jake Archibald - Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
