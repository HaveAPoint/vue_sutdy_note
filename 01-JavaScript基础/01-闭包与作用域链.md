# 闭包与作用域链

## 本质

### 闭包 (Closure)

**闭包 = 函数 + 函数能够访问的外部变量**

当一个函数可以记住并访问它定义时所在的词法作用域，即使这个函数在其词法作用域之外执行，就产生了闭包。

```javascript
function outer() {
  const name = 'closure'  // 外部变量

  function inner() {
    console.log(name)     // 访问外部变量
  }

  return inner            // 返回内部函数
}

const fn = outer()
fn()  // 输出 'closure'，即使 outer 已经执行完毕
```

### 作用域链 (Scope Chain)

作用域链是 JavaScript 查找变量的机制：**从当前作用域开始，逐级向上查找，直到全局作用域**。

```javascript
const global = 'global'

function outer() {
  const outerVar = 'outer'

  function inner() {
    const innerVar = 'inner'
    console.log(innerVar)   // 当前作用域找到
    console.log(outerVar)   // 向上一级找到
    console.log(global)     // 继续向上，全局作用域找到
  }

  inner()
}
```

## 闭包的形成条件

1. 函数嵌套
2. 内部函数引用外部函数的变量
3. 内部函数被返回或传递到外部

```javascript
// 经典闭包模式
function createCounter() {
  let count = 0  // 私有变量

  return {
    increment() { count++ },
    decrement() { count-- },
    getCount() { return count }
  }
}

const counter = createCounter()
counter.increment()
counter.increment()
console.log(counter.getCount())  // 2
// count 变量对外不可见，但闭包可以访问
```

## 作用域类型

### 1. 全局作用域

```javascript
var globalVar = 'global'  // 全局变量
```

### 2. 函数作用域

```javascript
function fn() {
  var funcVar = 'function'  // 只在函数内有效
}
```

### 3. 块级作用域 (ES6+)

```javascript
{
  let blockVar = 'block'    // 只在块内有效
  const constVar = 'const'  // 同上
}
// blockVar 和 constVar 在这里不可访问
```

## 闭包的应用场景

### 1. 数据私有化（模块模式）

```javascript
const bankAccount = (function() {
  let balance = 0  // 私有变量

  return {
    deposit(amount) {
      balance += amount
      return balance
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount
        return balance
      }
      return '余额不足'
    },
    getBalance() {
      return balance
    }
  }
})()

bankAccount.deposit(100)    // 100
bankAccount.withdraw(30)    // 70
bankAccount.getBalance()    // 70
// bankAccount.balance      // undefined，无法直接访问
```

### 2. 函数柯里化

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs))
    }
  }
}

function add(a, b, c) {
  return a + b + c
}

const curriedAdd = curry(add)
curriedAdd(1)(2)(3)  // 6
curriedAdd(1, 2)(3)  // 6
```

### 3. 防抖节流（见单独章节）

### 4. 缓存（记忆化）

```javascript
function memoize(fn) {
  const cache = {}  // 闭包保存缓存

  return function(...args) {
    const key = JSON.stringify(args)
    if (cache[key]) {
      return cache[key]
    }
    const result = fn.apply(this, args)
    cache[key] = result
    return result
  }
}

const expensiveCalc = memoize((n) => {
  console.log('computing...')
  return n * n
})

expensiveCalc(5)  // computing... 25
expensiveCalc(5)  // 25 (从缓存读取，不再计算)
```

## 经典面试题

### 1. 循环中的闭包问题

```javascript
// 问题代码
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i)  // 输出 3, 3, 3
  }, 1000)
}
// 原因：var 没有块级作用域，闭包引用的是同一个 i

// 解决方案1：使用 let
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i)  // 输出 0, 1, 2
  }, 1000)
}

// 解决方案2：使用 IIFE 创建新作用域
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j)  // 输出 0, 1, 2
    }, 1000)
  })(i)
}
```

### 2. 闭包内存问题

```javascript
function createHugeArray() {
  const hugeArray = new Array(1000000).fill('data')

  return function() {
    // 即使只返回长度，hugeArray 也不会被回收
    return hugeArray.length
  }
}

const getLength = createHugeArray()
// hugeArray 一直存在于内存中

// 解决：及时解除引用
// getLength = null
```

### 3. 作用域链查找顺序

```javascript
var name = 'global'

function outer() {
  var name = 'outer'

  function inner() {
    var name = 'inner'
    console.log(name)  // 输出什么？
  }

  inner()
}

outer()  // 输出 'inner'
// 作用域链：inner -> outer -> global
// 在 inner 作用域就找到了 name
```

## 闭包的优缺点

### 优点

- 实现数据私有化和封装
- 保持变量在内存中，延长生命周期
- 创建工厂函数和高阶函数

### 缺点

- 可能导致内存泄漏（变量无法被回收）
- 过度使用会使代码难以维护和调试

## 总结

| 概念 | 定义 | 关键点 |
|------|------|--------|
| 闭包 | 函数 + 外部变量的引用 | 函数记住定义时的作用域 |
| 作用域链 | 变量查找的链式路径 | 从内到外，就近原则 |
| 词法作用域 | 编写时确定的作用域 | 静态作用域，与调用位置无关 |

## 深入阅读

- [MDN - 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
- [You Don't Know JS - 作用域与闭包](https://github.com/getify/You-Dont-Know-JS)
