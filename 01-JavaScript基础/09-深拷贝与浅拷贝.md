# 深拷贝与浅拷贝

## 前置知识：数据类型

### 基本类型（值类型）
- `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`
- 存储在**栈内存**中
- 赋值时复制值本身

### 引用类型
- `object`, `array`, `function`, `date`, `regexp` 等
- 存储在**堆内存**中，栈中存储的是引用（地址）
- 赋值时复制的是引用

```javascript
// 基本类型：互不影响
let a = 1
let b = a
b = 2
console.log(a) // 1

// 引用类型：相互影响
let obj1 = { name: 'Tom' }
let obj2 = obj1
obj2.name = 'Jerry'
console.log(obj1.name) // 'Jerry' —— obj1 也被改了！
```

## 浅拷贝 (Shallow Copy)

**定义**：只复制一层，嵌套的对象/数组仍然是引用。

### 实现方式

#### 1. 扩展运算符 `...`

```javascript
const obj = { a: 1, b: { c: 2 } }
const shallowCopy = { ...obj }

shallowCopy.a = 100
console.log(obj.a) // 1 —— 基本类型不影响

shallowCopy.b.c = 200
console.log(obj.b.c) // 200 —— 嵌套对象被影响！
```

#### 2. Object.assign()

```javascript
const obj = { a: 1, b: { c: 2 } }
const shallowCopy = Object.assign({}, obj)
```

#### 3. 数组方法

```javascript
const arr = [1, 2, { x: 3 }]

// 以下都是浅拷贝
const copy1 = arr.slice()
const copy2 = arr.concat()
const copy3 = [...arr]
const copy4 = Array.from(arr)
```

## 深拷贝 (Deep Copy)

**定义**：完全复制所有层级，新对象与原对象完全独立。

### 实现方式

#### 1. JSON.parse(JSON.stringify()) — 简单但有缺陷

```javascript
const obj = { a: 1, b: { c: 2 } }
const deepCopy = JSON.parse(JSON.stringify(obj))

deepCopy.b.c = 200
console.log(obj.b.c) // 2 —— 原对象不受影响
```

**致命缺陷**：

```javascript
const obj = {
  fn: function() {},       // 函数 -> 丢失
  date: new Date(),        // Date -> 变成字符串
  reg: /abc/,              // RegExp -> 变成空对象 {}
  undef: undefined,        // undefined -> 丢失
  nan: NaN,                // NaN -> 变成 null
  infinity: Infinity,      // Infinity -> 变成 null
  sym: Symbol('test'),     // Symbol -> 丢失
}

const copy = JSON.parse(JSON.stringify(obj))
console.log(copy)
// { date: "2024-01-01T00:00:00.000Z", reg: {}, nan: null, infinity: null }
```

**还有一个问题**：无法处理循环引用

```javascript
const obj = { a: 1 }
obj.self = obj  // 循环引用

JSON.parse(JSON.stringify(obj)) // 报错！TypeError: Converting circular structure to JSON
```

#### 2. structuredClone() — 现代浏览器推荐

```javascript
const obj = {
  date: new Date(),
  arr: [1, 2, 3],
  nested: { x: 1 }
}

const deepCopy = structuredClone(obj)
```

**优点**：
- 支持循环引用
- 支持 Date, RegExp, Map, Set, ArrayBuffer 等

**缺点**：
- 不支持函数
- 不支持 Symbol
- 不支持 DOM 节点

#### 3. 手写递归深拷贝（面试重点）

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // 处理 null 和非对象
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj)
  }

  // 处理特殊对象类型
  if (obj instanceof Date) {
    return new Date(obj)
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj)
  }
  if (obj instanceof Map) {
    const mapCopy = new Map()
    hash.set(obj, mapCopy)
    obj.forEach((value, key) => {
      mapCopy.set(deepClone(key, hash), deepClone(value, hash))
    })
    return mapCopy
  }
  if (obj instanceof Set) {
    const setCopy = new Set()
    hash.set(obj, setCopy)
    obj.forEach(value => {
      setCopy.add(deepClone(value, hash))
    })
    return setCopy
  }

  // 处理数组和普通对象
  const copy = Array.isArray(obj) ? [] : {}
  hash.set(obj, copy)

  // 拷贝自身属性（包括 Symbol 属性）
  Reflect.ownKeys(obj).forEach(key => {
    copy[key] = deepClone(obj[key], hash)
  })

  return copy
}
```

**测试**：

```javascript
const obj = {
  a: 1,
  b: { c: 2 },
  arr: [1, 2, 3],
  date: new Date(),
  reg: /abc/g,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
  [Symbol('sym')]: 'symbol value'
}
obj.self = obj // 循环引用

const copy = deepClone(obj)
copy.b.c = 200
console.log(obj.b.c) // 2 —— 原对象不受影响
console.log(copy.self === copy) // true —— 循环引用正确处理
```

## 对比总结

| 方法 | 类型 | 函数 | Date/RegExp | 循环引用 | Symbol |
|------|------|------|-------------|----------|--------|
| `...` / `Object.assign` | 浅拷贝 | ✅ | ✅ | ✅ | ✅ |
| `JSON.parse/stringify` | 深拷贝 | ❌ | ❌ | ❌ | ❌ |
| `structuredClone` | 深拷贝 | ❌ | ✅ | ✅ | ❌ |
| 手写递归 | 深拷贝 | ✅ | ✅ | ✅ | ✅ |

## 面试要点

1. **浅拷贝只复制一层**，嵌套对象仍是引用
2. **JSON 方法有缺陷**：不支持函数、Date、RegExp、循环引用
3. **structuredClone 是现代方案**，但不支持函数
4. **手写深拷贝**需要考虑：
   - 循环引用（用 WeakMap 记录）
   - 特殊类型（Date, RegExp, Map, Set）
   - Symbol 属性（用 Reflect.ownKeys）
5. **实际开发中**推荐使用 lodash 的 `_.cloneDeep()`

## 深入阅读

- [MDN - structuredClone](https://developer.mozilla.org/zh-CN/docs/Web/API/structuredClone)
- [lodash - cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep)
