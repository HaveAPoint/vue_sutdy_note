# 类型判断方法

## JavaScript 数据类型

### 基本类型（7 种）
- `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

### 引用类型
- `object`（包括普通对象、数组、函数、Date、RegExp、Map、Set 等）

## 类型判断方法对比

### 1. typeof

**特点**：返回字符串，适合判断基本类型。

```javascript
typeof 'hello'      // 'string'
typeof 123          // 'number'
typeof true         // 'boolean'
typeof undefined    // 'undefined'
typeof Symbol()     // 'symbol'
typeof 123n         // 'bigint'

// 坑点！
typeof null         // 'object' —— 历史遗留 bug
typeof []           // 'object' —— 无法区分数组
typeof {}           // 'object'
typeof function(){} // 'function' —— 唯一能识别的引用类型
typeof new Date()   // 'object'
```

**结论**：`typeof` 无法区分 `null`、数组、对象、Date 等。

### 2. instanceof

**特点**：判断对象是否是某个构造函数的实例（沿原型链查找）。

```javascript
[] instanceof Array       // true
[] instanceof Object      // true（数组也是对象）
{} instanceof Object      // true

function Person() {}
const p = new Person()
p instanceof Person       // true
p instanceof Object       // true

// 坑点！
'hello' instanceof String   // false（基本类型不是实例）
new String('hello') instanceof String  // true

// 跨 iframe 问题
// iframe 中的数组 instanceof 当前页面的 Array 会返回 false
```

**原理**：

```javascript
function myInstanceof(obj, Constructor) {
  let proto = Object.getPrototypeOf(obj)
  while (proto) {
    if (proto === Constructor.prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```

### 3. Object.prototype.toString.call()

**特点**：最准确的类型判断方法，返回 `[object Type]` 格式。

```javascript
Object.prototype.toString.call('hello')     // '[object String]'
Object.prototype.toString.call(123)         // '[object Number]'
Object.prototype.toString.call(true)        // '[object Boolean]'
Object.prototype.toString.call(undefined)   // '[object Undefined]'
Object.prototype.toString.call(null)        // '[object Null]' ✓
Object.prototype.toString.call(Symbol())    // '[object Symbol]'
Object.prototype.toString.call(123n)        // '[object BigInt]'

Object.prototype.toString.call([])          // '[object Array]' ✓
Object.prototype.toString.call({})          // '[object Object]'
Object.prototype.toString.call(function(){})// '[object Function]'
Object.prototype.toString.call(new Date())  // '[object Date]'
Object.prototype.toString.call(/abc/)       // '[object RegExp]'
Object.prototype.toString.call(new Map())   // '[object Map]'
Object.prototype.toString.call(new Set())   // '[object Set]'
```

**封装工具函数**：

```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}

getType('hello')  // 'string'
getType([])       // 'array'
getType(null)     // 'null'
getType(new Date()) // 'date'
```

### 4. Array.isArray()

**特点**：专门判断数组，解决跨 iframe 问题。

```javascript
Array.isArray([])           // true
Array.isArray({})           // false
Array.isArray('hello')      // false
Array.isArray(new Array())  // true
```

### 5. constructor

**特点**：通过 constructor 属性判断。

```javascript
'hello'.constructor === String   // true
[].constructor === Array         // true
{}.constructor === Object        // true

// 坑点：
// 1. null 和 undefined 没有 constructor
// 2. constructor 可以被修改
function Foo() {}
Foo.prototype.constructor = Object
new Foo().constructor === Object // true（被篡改了）
```

### 6. 特殊值判断

```javascript
// 判断 NaN
Number.isNaN(NaN)       // true
Number.isNaN('hello')   // false（不会类型转换）
isNaN('hello')          // true（会类型转换，不推荐）

// 判断有限数
Number.isFinite(123)    // true
Number.isFinite(Infinity) // false

// 判断整数
Number.isInteger(123)   // true
Number.isInteger(1.5)   // false

// 判断 null
value === null

// 判断 undefined
value === undefined
typeof value === 'undefined'
```

## 对比总结

| 方法 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| `typeof` | 基本类型、函数 | 简单快速 | null 返回 object，无法区分对象类型 |
| `instanceof` | 对象类型 | 能判断继承关系 | 不能判断基本类型，跨 iframe 有问题 |
| `toString.call()` | 所有类型 | 最准确全面 | 写法繁琐 |
| `Array.isArray()` | 数组 | 简单，解决跨 iframe | 只能判断数组 |
| `constructor` | 对象类型 | 能获取构造函数 | null/undefined 报错，可被篡改 |

## 实用工具函数

```javascript
// 完整的类型判断工具
const typeUtils = {
  getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
  },
  isString(value) {
    return typeof value === 'string'
  },
  isNumber(value) {
    return typeof value === 'number' && !Number.isNaN(value)
  },
  isBoolean(value) {
    return typeof value === 'boolean'
  },
  isNull(value) {
    return value === null
  },
  isUndefined(value) {
    return value === undefined
  },
  isObject(value) {
    return value !== null && typeof value === 'object'
  },
  isPlainObject(value) {
    return this.getType(value) === 'object'
  },
  isArray(value) {
    return Array.isArray(value)
  },
  isFunction(value) {
    return typeof value === 'function'
  },
  isDate(value) {
    return this.getType(value) === 'date'
  },
  isRegExp(value) {
    return this.getType(value) === 'regexp'
  },
  isPromise(value) {
    return this.getType(value) === 'promise'
  },
  isEmpty(value) {
    if (value == null) return true
    if (this.isArray(value) || this.isString(value)) return value.length === 0
    if (this.isPlainObject(value)) return Object.keys(value).length === 0
    if (value instanceof Map || value instanceof Set) return value.size === 0
    return false
  }
}
```

## 面试经典题

### 题目 1：如何判断一个变量是数组？

```javascript
// 方法 1：Array.isArray()（推荐）
Array.isArray([]) // true

// 方法 2：Object.prototype.toString.call()
Object.prototype.toString.call([]) === '[object Array]'

// 方法 3：instanceof（有跨 iframe 问题）
[] instanceof Array

// 方法 4：constructor（可被篡改）
[].constructor === Array
```

### 题目 2：如何判断一个对象是空对象？

```javascript
// 方法 1：Object.keys()
Object.keys({}).length === 0

// 方法 2：JSON.stringify()
JSON.stringify({}) === '{}'

// 方法 3：for...in
function isEmpty(obj) {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) return false
  }
  return true
}
```

### 题目 3：typeof null 为什么是 object？

这是 JavaScript 的历史遗留 bug。在最初的实现中，值以 32 位存储，类型标签存储在低位。对象的类型标签是 000，而 null 被表示为空指针（全零），所以它的类型标签也是 000，被误判为 object。

## 面试要点

1. **typeof 返回字符串**，只能准确判断基本类型（除 null）和函数
2. **instanceof 沿原型链查找**，不能判断基本类型
3. **Object.prototype.toString.call() 最准确**，记住格式 `[object Type]`
4. **Array.isArray() 是判断数组的最佳方法**
5. **typeof null === 'object'** 是历史 bug

## 深入阅读

- [MDN - typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)
- [MDN - instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)
