# Vue 核心原点二：组件 = 函数

## 本质

把 Vue 组件理解为一个纯函数：

```
f(props, state) → UI
```

- **输入**：props（外部参数）+ state（内部状态）
- **输出**：渲染的 DOM 结构
- **副作用**：emit 事件、API 调用、生命周期钩子

## 组件的三要素

### 1. Props - 外部输入

```vue
<script setup>
// 声明 props
const props = defineProps({
  title: String,
  count: {
    type: Number,
    default: 0
  }
})
</script>

<template>
  <h1>{{ title }}</h1>
</template>
```

**Props 是只读的**，子组件不应该修改它。这是单向数据流的约定。

### 2. State - 内部状态

```vue
<script setup>
import { ref, reactive } from 'vue'

// 内部状态，组件私有
const count = ref(0)
const form = reactive({
  username: '',
  password: ''
})
</script>
```

### 3. Emit - 输出事件

```vue
<script setup>
const emit = defineEmits(['update', 'delete'])

function handleClick() {
  emit('update', { id: 1, value: 'new' })
}
</script>
```

## 组件 = 封装 + 复用

### 封装

组件把 UI + 逻辑 + 样式封装在一起：

```
Button.vue
├── <template>  → 结构（HTML）
├── <script>    → 逻辑（JavaScript）
└── <style>     → 样式（CSS）
```

### 单文件组件结构详解

```vue
<template>
  <!-- HTML：页面长什么样 -->
  <div>
    <h1>{{ title }}</h1>
    <button @click="count++">点击了 {{ count }} 次</button>
  </div>
</template>

<script setup>
// JavaScript：逻辑和数据
import { ref } from 'vue'

const title = '你好'
const count = ref(0)
</script>

<style scoped>
/* CSS：样式（scoped 表示只作用于当前组件） */
h1 {
  color: blue;
}
</style>
```

| 部分 | 语言 | 职责 |
|------|------|------|
| `<template>` | HTML | 定义 UI 结构，使用 `{{ }}` 插入数据 |
| `<script>` | JavaScript | 定义数据、函数、逻辑 |
| `<style>` | CSS | 定义颜色、大小、布局等样式 |

### 何时拆分，何时合并？

**默认：放在一起（单文件组件）**

大多数情况下，三部分放在一个 `.vue` 文件中：

```vue
<!-- UserCard.vue - 一个文件搞定 -->
<template>...</template>
<script setup>...</script>
<style scoped>...</style>
```

**拆分场景 1：逻辑复用 → 抽取 Composables**

当逻辑需要在多个组件中复用时，把 `<script>` 中的逻辑抽到单独的 `.ts` 文件：

```
components/
├── UserList.vue        # template + 简单 script + style
├── OrderList.vue       # 复用同样的分页逻辑
composables/
└── usePagination.ts    # 抽取出来的逻辑
```

**拆分场景 2：样式复用 → 抽取公共样式**

```
styles/
├── variables.css       # 颜色、字体等变量
├── common.css          # 公共样式
components/
└── Button.vue          # @import 引入公共样式
```

**拆分场景 3：组件过大 → 拆成子组件**

当一个 `.vue` 文件超过 300-400 行时，考虑拆分：

```
views/user/
├── UserDetail.vue           # 主组件（容器）
└── components/
    ├── UserHeader.vue       # 子组件
    ├── UserProfile.vue
    └── UserActions.vue
```

### 拆分决策表

| 情况 | 建议 |
|------|------|
| 组件 < 200 行 | 保持单文件 |
| 逻辑需要复用 | 抽取到 composables/ |
| 样式需要复用 | 抽取到 styles/ |
| 组件 > 400 行 | 拆分成多个子组件 |
| 纯展示型小组件 | 保持单文件，越简单越好 |

**原则：先合后拆。** 不要过早拆分，等真正感到痛点时再拆。

### 复用

```vue
<!-- 同一个组件，不同的 props，渲染不同的结果 -->
<UserCard :user="user1" />
<UserCard :user="user2" />
<UserCard :user="user3" />
```

### 如何在模板中引用组件

1) 注册：在 `components/` 里放 `UserCard.vue`，父组件里 `import UserCard from './components/UserCard.vue'`，并在 `<script setup>` 直接使用（或在常规 `<script>` 里 `components: { UserCard }`）。

2) 使用：在模板中写 `<UserCard :user="user" @update="handleUpdate" />`。

3) 数据流：

- 父 → 子：用 `props` 传值（例如 `:user="user"`）。
- 子 → 父：用 `emit` 事件（例如子里 `emit('update', payload)`，父里 `@update="handleUpdate"` 接收）。

4) 提示：组件名在模板里用 PascalCase 或 kebab-case 都行，如 `<user-card />` 等价 `<UserCard />`。

## 生命周期 = 函数的执行时机

```
组件创建 → 挂载到 DOM → 更新 → 卸载
   ↓           ↓          ↓       ↓
onBeforeMount onMounted onUpdated onUnmounted
```

```vue
<script setup>
import { onMounted, onUnmounted } from 'vue'

onMounted(() => {
  // 组件挂载后执行，适合：
  // - 获取 DOM 引用
  // - 发起初始 API 请求
  // - 添加事件监听
  console.log('组件已挂载')
})

onUnmounted(() => {
  // 组件销毁前执行，适合：
  // - 清理定时器
  // - 移除事件监听
  // - 取消未完成的请求
  console.log('组件将卸载')
})
</script>
```


按**选项类型**组织代码，同一功能的代码分散在不同选项中。

### Composition API（Vue 3 推荐）

```vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)
const double = computed(() => count.value * 2)
function increment() { count.value++ }
</script>
```

按**功能逻辑**组织代码，相关代码放在一起，更容易复用和维护。

## 组合式函数 (Composables)

把可复用的逻辑抽成函数：

```javascript
// composables/useMouse.js
import { ref, onMounted, onUnmounted } from 'vue'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  function update(e) {
    x.value = e.pageX
    y.value = e.pageY
  }

  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))

  return { x, y }
}
```

```vue
<script setup>
import { useMouse } from './composables/useMouse'

const { x, y } = useMouse()
</script>

<template>
  <div>鼠标位置: {{ x }}, {{ y }}</div>
</template>
```

## 后端类比

| Vue 概念 | 后端类比 |
|----------|----------|
| 组件 | Controller / Handler |
| Props | 请求参数 |
| State | 会话状态 / 局部变量 |
| Emit | 返回响应 / 发布事件 |
| Composables | Service 层 / 工具类 |
| 生命周期 | 中间件 / 拦截器 |
