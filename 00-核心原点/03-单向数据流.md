# Vue 核心原点三：单向数据流

## 本质

```
父组件 ──props──→ 子组件
父组件 ←──emit── 子组件
```

- **数据向下流**：父组件通过 props 传递数据给子组件
- **事件向上冒**：子组件通过 emit 通知父组件发生了什么

这是 Vue 组件通信的黄金法则。

## 为什么是单向的？

### 可预测性

如果子组件能随意修改父组件的数据，当出现 bug 时，你很难追踪数据是在哪里被改的。

单向数据流保证：**数据的所有者负责修改数据**。

### 类比

就像后端的**不可变性原则**：

- Props 像函数参数，传进来的不要改
- 想改？通知调用方，让它来改

## 基本模式

### 父 → 子：Props

```vue
<!-- Parent.vue -->
<template>
  <Child :message="msg" :count="num" />
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello')
const num = ref(0)
</script>
```

```vue
<!-- Child.vue -->
<script setup>
const props = defineProps({
  message: String,
  count: Number
})

// props 是只读的，直接修改会报警告
// props.count = 1  // 错误！
</script>
```

### 子 → 父：Emit

```vue
<!-- Child.vue -->
<template>
  <button @click="handleClick">点击</button>
</template>

<script setup>
const emit = defineEmits(['increment'])

function handleClick() {
  emit('increment', 1)  // 通知父组件
}
</script>
```

```vue
<!-- Parent.vue -->
<template>
  <Child @increment="handleIncrement" />
  <p>计数: {{ count }}</p>
</template>

<script setup>
import { ref } from 'vue'
const count = ref(0)

function handleIncrement(value) {
  count.value += value  // 父组件自己修改数据
}
</script>
```

## v-model：双向绑定的语法糖

`v-model` 看起来是双向绑定，但本质上还是单向数据流的封装：

```vue
<!-- 这个 -->
<Child v-model="count" />

<!-- 等价于 -->
<Child :modelValue="count" @update:modelValue="count = $event" />
```

子组件内部：

```vue
<script setup>
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

function updateValue(newVal) {
  emit('update:modelValue', newVal)
}
</script>
```

## 跨层级通信

### 问题：Props 层层传递（Prop Drilling）

```
App
 └── Page
      └── Section
           └── Card
                └── Button  ← 需要 App 的数据，但要经过 4 层传递
```

### 解决方案 1：Provide / Inject

```vue
<!-- 祖先组件 -->
<script setup>
import { provide, ref } from 'vue'

const theme = ref('dark')
provide('theme', theme)  // 提供数据
</script>
```

```vue
<!-- 任意后代组件 -->
<script setup>
import { inject } from 'vue'

const theme = inject('theme')  // 注入数据
</script>
```

### 解决方案 2：状态管理（Pinia）

当多个组件需要共享状态时，使用集中式状态管理：

```javascript
// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0 }),
  actions: {
    increment() {
      this.count++
    }
  }
})
```

```vue
<!-- 任意组件 -->
<script setup>
import { useCounterStore } from '@/stores/counter'

const counter = useCounterStore()
</script>

<template>
  <button @click="counter.increment">
    {{ counter.count }}
  </button>
</template>
```

## 通信方式选择指南

| 场景 | 推荐方式 |
|------|----------|
| 父 → 子 | props |
| 子 → 父 | emit |
| 父 ↔ 子双向 | v-model |
| 跨多层组件 | provide / inject |
| 多组件共享状态 | Pinia |
| 兄弟组件通信 | 提升状态到共同父组件，或用 Pinia |

## 后端类比

| Vue 概念 | 后端类比 |
|----------|----------|
| Props | 方法参数、DTO |
| Emit | 回调函数、事件发布 |
| Provide/Inject | 依赖注入、Context |
| Pinia | Redis、数据库、共享状态存储 |

## 常见错误

### 1. 子组件直接修改 props

```javascript
// 错误
props.count++

// 正确
emit('update:count', props.count + 1)
```

### 2. 过度使用全局状态

不是所有状态都要放 Pinia。局部状态用组件内部管理，只有真正需要跨组件共享的才用全局状态。

### 3. 事件命名不规范

```javascript
// 推荐：kebab-case 命名
emit('user-updated', data)

// 避免：驼峰或无意义命名
emit('foo', data)
```
