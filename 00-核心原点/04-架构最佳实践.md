# Vue 架构最佳实践

## 项目结构

```
src/
├── api/                # API 请求封装
│   ├── index.ts        # axios 实例配置
│   └── modules/        # 按业务模块拆分
│       ├── user.ts
│       └── order.ts
├── components/         # 通用组件（跨页面复用）
│   ├── BaseButton.vue
│   └── BaseModal.vue
├── composables/        # 组合式函数（逻辑复用）
│   ├── useAuth.ts
│   └── usePagination.ts
├── stores/             # Pinia 状态管理
│   ├── user.ts
│   └── app.ts
├── views/              # 页面组件（路由对应）
│   └── user/
│       ├── UserList.vue
│       ├── UserDetail.vue
│       └── components/ # 页面私有组件
├── router/             # 路由配置
├── types/              # TypeScript 类型定义
└── utils/              # 工具函数
```

**原则：按功能分层，层内按业务模块拆分。**

### 路径别名（Path Alias）

约定使用 `@` 符号代表 `src/` 根目录。这意味着无论当前文件在哪里，`@` 都直接指向 `src` 文件夹。

```javascript
// 推荐：路径清晰，无论当前文件在哪都可以直接引用
import { getUsers } from '@/api/modules/user'

// 不推荐：层级混乱，移动文件后容易报错
import { getUsers } from '../../../api/modules/user'
```

## 组件设计

### 容器组件 vs 展示组件

```
容器组件（Smart）        展示组件（Dumb）
├── 处理数据获取          ├── 只负责 UI 渲染
├── 管理状态              ├── 通过 props 接收数据
├── 调用 API             ├── 通过 emit 抛出事件
└── 组合展示组件          └── 高度可复用
```

```vue
<!-- 容器组件：UserList.vue -->
<template>
  <UserTable :users="users" :loading="loading" @delete="handleDelete" />
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { getUsers, deleteUser } from '@/api/modules/user'
import UserTable from './components/UserTable.vue'

const users = ref([])
const loading = ref(false)

onMounted(async () => {
  loading.value = true
  users.value = await getUsers()
  loading.value = false
})

async function handleDelete(id) {
  await deleteUser(id)
  users.value = users.value.filter(u => u.id !== id)
}
</script>
```

```vue
<!-- 展示组件：UserTable.vue -->
<template>
  <table>
    <tr v-for="user in users" :key="user.id">
      <td>{{ user.name }}</td>
      <td><button @click="$emit('delete', user.id)">删除</button></td>
    </tr>
  </table>
</template>

<script setup>
defineProps(['users', 'loading'])
defineEmits(['delete'])
</script>
```

### 组件命名规范

```
BaseXxx.vue     → 基础通用组件（BaseButton, BaseInput）
TheXxx.vue      → 单例组件（TheHeader, TheSidebar）
AppXxx.vue      → 应用级组件（AppLoading）
[Domain]Xxx.vue → 业务组件（UserCard, OrderList）
```

## 状态管理策略

### 什么放哪里？

| 状态类型 | 存放位置 | 示例 |
|----------|----------|------|
| UI 状态 | 组件内部 `ref` | 弹窗开关、表单输入、loading |
| 页面状态 | 容器组件 | 列表数据、分页信息 |
| 跨组件共享 | Pinia store | 用户信息、权限、主题 |
| 服务端缓存 | 请求库缓存 | API 响应数据（可用 TanStack Query） |

### Pinia Store 设计

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { login, getUserInfo } from '@/api/modules/user'

export const useUserStore = defineStore('user', () => {
  // state
  const token = ref<string | null>(localStorage.getItem('token'))
  const userInfo = ref<User | null>(null)

  // getters
  const isLoggedIn = computed(() => !!token.value)
  const isAdmin = computed(() => userInfo.value?.role === 'admin')

  // actions
  async function loginAction(credentials: LoginParams) {
    const res = await login(credentials)
    token.value = res.token
    localStorage.setItem('token', res.token)
  }

  function logout() {
    token.value = null
    userInfo.value = null
    localStorage.removeItem('token')
  }

  return { token, userInfo, isLoggedIn, isAdmin, loginAction, logout }
})
```

**原则：Store 只存真正需要跨组件共享的状态，不要把所有状态都塞进去。**

## API 层封装

### 什么是 Axios？

Axios 是一个基于 Promise 的 HTTP 客户端，可以运行在浏览器和 Node.js 中。
在前后端分离架构中，它扮演着**数据桥梁**的角色，负责将前端的请求发送给后端，并将后端的数据带回前端。

**主要特点：**
- **支持 Promise**：可以用 `async/await` 写出同步风格的代码。
- **拦截器**：可以在请求发送前和响应返回后进行统一处理（如添加 Token、统一报错）。
- **自动 JSON 转换**：自动将请求数据转为 JSON，将响应 JSON 转为对象。

### axios 实例

```typescript
// api/index.ts
import axios from 'axios'
import { useUserStore } from '@/stores/user'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE,
  timeout: 10000
})

// 请求拦截：自动带 token
request.interceptors.request.use(config => {
  const userStore = useUserStore()
  if (userStore.token) {
    config.headers.Authorization = `Bearer ${userStore.token}`
  }
  return config
})

// 响应拦截：统一错误处理
request.interceptors.response.use(
  res => res.data,
  error => {
    if (error.response?.status === 401) {
      useUserStore().logout()
      router.push('/login')
    }
    return Promise.reject(error)
  }
)

export default request
```

### API 模块

```typescript
// api/modules/user.ts
import request from '../index'

export interface User {
  id: number
  name: string
  email: string
}

export const getUsers = () => request.get<User[]>('/users')
export const getUser = (id: number) => request.get<User>(`/users/${id}`)
export const createUser = (data: Partial<User>) => request.post('/users', data)
export const updateUser = (id: number, data: Partial<User>) => request.put(`/users/${id}`, data)
export const deleteUser = (id: number) => request.delete(`/users/${id}`)
```

## Composables 设计

### 何时抽取 Composable？

1. **逻辑在多个组件中重复**
2. **组件逻辑过于复杂，需要拆分**
3. **需要封装副作用（事件监听、定时器等）**

### 示例：分页逻辑

```typescript
// composables/usePagination.ts
import { ref, computed } from 'vue'

export function usePagination<T>(fetchFn: (page: number) => Promise<{ data: T[], total: number }>) {
  const data = ref<T[]>([])
  const currentPage = ref(1)
  const pageSize = ref(10)
  const total = ref(0)
  const loading = ref(false)

  const totalPages = computed(() => Math.ceil(total.value / pageSize.value))

  async function loadPage(page: number) {
    loading.value = true
    try {
      const res = await fetchFn(page)
      data.value = res.data
      total.value = res.total
      currentPage.value = page
    } finally {
      loading.value = false
    }
  }

  function nextPage() {
    if (currentPage.value < totalPages.value) {
      loadPage(currentPage.value + 1)
    }
  }

  function prevPage() {
    if (currentPage.value > 1) {
      loadPage(currentPage.value - 1)
    }
  }

  return { data, currentPage, pageSize, total, totalPages, loading, loadPage, nextPage, prevPage }
}
```

```vue
<script setup>
import { usePagination } from '@/composables/usePagination'
import { getUsers } from '@/api/modules/user'

const { data: users, loading, currentPage, totalPages, loadPage } = usePagination(getUsers)

loadPage(1)
</script>
```

## TypeScript 最佳实践

### Props 类型定义

```vue
<script setup lang="ts">
interface Props {
  title: string
  count?: number
  items: Array<{ id: number; name: string }>
}

const props = withDefaults(defineProps<Props>(), {
  count: 0
})
</script>
```

### Emit 类型定义

```vue
<script setup lang="ts">
const emit = defineEmits<{
  update: [value: string]
  delete: [id: number]
}>()
</script>
```

## 后端类比总结

| Vue 概念 | 后端类比 |
|----------|----------|
| views/ | Controller 层 |
| components/ | 可复用的 View 组件 |
| composables/ | Service 层 |
| stores/ | 应用级状态 / Session |
| api/ | Repository / Client 层 |
| types/ | DTO / Entity 定义 |
| router/ | 路由配置 / URL 映射 |

## 核心原则

1. **关注点分离**：UI、逻辑、数据获取分开
2. **单一职责**：一个组件/函数只做一件事
3. **最小化状态提升**：状态放在需要它的最近公共祖先
4. **组合优于继承**：用 composables 复用逻辑，不要用 mixins
5. **类型先行**：先定义接口类型，再写实现
