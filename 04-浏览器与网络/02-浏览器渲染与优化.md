# 浏览器渲染与优化：重排与重绘

## 核心概念

### 1. 回流 / 重排 (Reflow)
**布局改变**。当元素的尺寸、位置、隐藏/显示状态发生改变，浏览器需要重新计算几何属性，并重新构建渲染树。

**触发条件**：
- 添加/删除 DOM 节点
- 改变 margin, padding, border, width, height
- 内容改变（文本、图片大小）
- 浏览器窗口 resize
- **获取布局信息** (如 `offsetWidth`, `scrollTop`) —— **这点常被忽略！**

### 2. 重绘 (Repaint)
**外观改变**。元素的外观（颜色、背景、阴影）变了，但尺寸位置没变，只需重新绘制像素。

**触发条件**：
- `color`
- `background-color`
- `visibility: hidden`

---

## 关系结论 (重要)

- **回流 必将引起 重绘**。
- **重绘 不一定引起 回流**。

**回流的成本远高于重绘**，因为回流可能导致父节点、兄弟节点甚至整个文档的布局重新计算。

---

## 优化手段（减少回流重绘）

### 1. 样式集中修改 (批量操作)

```javascript
// 糟糕写法：触发 3 次回流
el.style.width = '100px';
el.style.height = '100px';
el.style.left = '10px';

// 推荐写法：使用 class (1 次回流)
el.classList.add('active');

// 或者 style.cssText
el.style.cssText = 'width: 100px; height: 100px; left: 10px;';
```

### 2. 读写分离 (避免强制同步布局)

```javascript
// 糟糕写法：读-写-读-写 (频繁中断渲染队列，强制回流)
const h1 = el1.offsetHeight;
el1.style.height = h1 + 10 + 'px';
const h2 = el2.offsetHeight;
el2.style.height = h2 + 10 + 'px';

// 推荐写法：先全读，再全写
const h1 = el1.offsetHeight;
const h2 = el2.offsetHeight;
el1.style.height = h1 + 10 + 'px';
el2.style.height = h2 + 10 + 'px';
```

### 3. DOM 离线操作

- **display: none**：先把元素隐藏（1次回流），进行 100 次修改，再显示（1次回流）。总共 2 次。
- **DocumentFragment**：创建文档碎片，在碎片上操作，最后一次性添加到 DOM。

```javascript
const fragment = document.createDocumentFragment();
for(let i=0; i<100; i++) {
  const li = document.createElement('li');
  fragment.appendChild(li);
}
ul.appendChild(fragment); // 只触发一次回流
```

### 4. 使用绝对定位 fixed / absolute
对于动画效果复杂的元素，将其**脱离文档流**。这样它的变化不会影响其他元素，只会触发自身的重绘/回流。

### 5. CSS3 硬件加速 (GPU)
使用 `transform`、`opacity`、`filters` 等属性，浏览器会开启 GPU 加速，创建一个新的复合层（Composite Layer），完全不触发回流重绘。

**最强优化**：用 `transform: translate` 代替 `left/top` 做位移。
