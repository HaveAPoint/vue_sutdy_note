# 跨域与同源策略

## 1. 什么是同源策略？

**浏览器**的一种安全机制。

**同源定义**：
- **协议**相同 (http / https)
- **域名**相同 (www.a.com / blog.a.com 不同)
- **端口**相同 (80 / 8080 不同)

如果不满足，就是**跨域**。跨域限制：
1.无法读取 Storage (Cookie, LocalStorage)。
2.无法操作 DOM。
3.发送 Ajax 请求会被浏览器拦截（其实请求发出去了，服务器也回了，但浏览器把响应拦住了）。

---

## 2. 解决方案

### 1. CORS (跨域资源共享) - 最推荐

**后端设置**请求头，告诉浏览器"我允许它跨域"。

```http
Access-Control-Allow-Origin: *                // 允许所有域名
Access-Control-Allow-Methods: POST, GET       // 允许的方法
Access-Control-Allow-Headers: Content-Type    // 允许的头
```

**简单请求 vs 复杂请求**：
- 复杂请求（如 PUT, application/json）会先发一个 **OPTIONS 预检请求**。

### 2. JSONP (已过时)

利用 `<script>` 标签没有跨域限制的漏洞。
- **缺点**：只支持 **GET** 请求。

```javascript
// 前端
function handleResponse(data) { console.log(data) }
<script src="http://api.com/user?callback=handleResponse"></script>

// 后端返回
handleResponse({ name: 'Tom' })
```

### 3. Nginx 反向代理 (生产环境常用)

浏览器 -> Nginx (同源) -> 目标服务器。
因为服务器之间通信没有跨域限制。

```nginx
# nginx.conf
server {
    listen 80;
    server_name www.a.com;

    location /api/ {
        proxy_pass http://www.b.com:8080/;  # 转发
    }
}
```

### 4. 开发环境代理 (Vue/Webpack/Vite)

原理同 Nginx，由 Node 开发服务器代理转发。

```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://backend.com',
        changeOrigin: true
      }
    }
  }
}
```

---

## 3. 面试陷阱：跨域是谁的问题？

是**浏览器**的问题，不是服务器的问题。
你用 Postman 或者后端 curl 请求，根本没有跨域这一说。
浏览器的目的是保护用户安全（防止 CSRF 等攻击）。
