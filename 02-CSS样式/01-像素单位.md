# CSS 像素单位

## 像素单位分类

| 单位 | 全称 | 类型 | 含义 | 推荐场景 |
|------|------|------|------|----------|
| **px** | Pixel | 绝对单位 | 屏幕物理像素 (逻辑像素) | 边框、固定尺寸元素 |
| **em** | 源自排版术语 (字母M宽度) | 相对单位 | 相对于**当前元素**的字体大小 | 首行缩进 |
| **rem** | Root EM | 相对单位 | 相对于**根元素 (html)** 的字体大小 | 响应式布局自适应 |
| **vw/vh** | Viewport Width/Height | 相对单位 | 相对于视口宽/高的 1% | 大屏适配、全屏布局 |
| **%** | Percent | 相对单位 | 相对于父盒子的属性值 | 宽度流式布局 |

---

## 详细辨析

### 1. px (像素)
- **特点**：最稳定的单位，不随浏览器缩放或父级变化而剧烈变化（除浏览器整体缩放外）。
- **问题**：在不同分辨率屏幕上（如移动端）可能显得过小或过大，缺乏灵活性。

### 2. em
- **基准**：继承父元素的 `font-size`。
- **陷阱**：多层嵌套时会发生"连锁反应"（复合计算）。
  ```css
  /* 父级 16px */
  .parent { font-size: 1.2em; } /* 19.2px */
  /* 子级 */
  .child { font-size: 1.2em; }  /* 19.2 * 1.2 = 23.04px */
  ```

### 3. rem (推荐)
- **基准**：只认 `<html>` 标签的 `font-size`。
- **优势**：避免了 em 的嵌套计算问题，同时具备响应式能力。
- **移动端适配原理**：通过 JS 动态控制 html 的 fontSize = 屏幕宽度 / 10，实现页面元素随屏幕等比缩放。

```css
html { font-size: 16px; }
div { width: 10rem; } /* 160px */
```

### 4. vw / vh
- `1vw` = 视口宽度的 1%。
- `100vh` = 视口高度的 100%。 (常用于全屏背景)
- **vmin / vmax**：取 vw 和 vh 中较小/较大的那个。

---

## 经典面试题

### 问题：如何让 1px 边框在高清屏（Retina）上真的只有 1 物理像素？

**背景**：
在 Retina 屏（DPR=2）上，CSS 的 `1px` 实际上会被渲染成 2 个物理像素，导致边框看起来很粗。

**解决方案：0.5px 边框**

#### 方法 1：直接写 0.5px (兼容性差)
```css
border: 0.5px solid black;
/* 仅部分新版浏览器支持 iOS 8+ */
```

#### 方法 2：Transform 缩放 (主流方案)
利用伪元素设置 1px 边框，然后将伪元素缩放 0.5 倍。

```css
.border-1px {
  position: relative;
}

.border-1px::after {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  width: 200%;    /* 宽变为 2 倍 */
  height: 200%;   /* 高变为 2 倍 */
  border: 1px solid #000;
  transform: scale(0.5); /* 整体缩放 0.5 */
  transform-origin: 0 0; /* 从左上角缩放 */
  box-sizing: border-box;
}
```

### 问题：移动端适配为何以前用 rem，现在很多用 vw？

- **rem 方案**（如 Flexible.js）：依赖 JS 设置 html font-size，有一定延迟，且计算稍微绕弯。
- **vw 方案**：原生支持，直接基于视口计算，无需 JS，不再从 html font-size 绕一圈，更加直接纯粹。

---

## 总结

- **做 PC 端**：默认用 `px`。
- **做移动端**：
  - 传统方案：`rem` + Flexible.js
  - 现代方案：`vw` / `vh`
- **全屏容器**：`100vh` 非常好用。
